const core = require('@actions/core');
const github = require('@actions/github');

const labelColour = '27ff28';
let octokit;

async function createNewLabel(owner, repo, label) {
  await octokit.rest.issues.createLabel({
    owner,
    repo,
    name: label,
    color: labelColour,
    description: 'Pull requests marked with this label will be automatically merged on approval'
  })
}

async function queryForExistingLabel(owner, repo, label) {
  let labelFound = false;
  try {
    await octokit.rest.issues.getLabel({
      owner,
      repo,
      name: label,
    });
    labelFound = true;
  } catch (error) {
    core.warning(`Get label error: ${error.message}`);
  }
  return labelFound;
}

async function assignLabelToPullRequest(owner, repo, label, issueNumber) {
  await octokit.rest.issues.addLabels({
    owner,
    repo,
    issue_number: issueNumber,
    labels: [label]
  });
  core.notice('Pull request - label added');
}

async function addLabel(owner, repo, issueNumber, label) {
    if (label !== null && label !== undefined && label !== '') {
    const labelFound = await queryForExistingLabel(owner, repo, label);

    if (labelFound === false) {
      await createNewLabel(owner, repo, label);
    }

    await assignLabelToPullRequest(owner, repo, label, issueNumber);
  }
}

function getInputs() {
  const sourceBranch = core.getInput('source_branch', {required: true });
  const targetBranch = core.getInput('target_branch', {required: true });
  const githubToken = core.getInput('github_token', {required: true });
  const label = core.getInput('label');
  const reviewers = core.getInput('reviewers');

  return {
    sourceBranch,
    targetBranch,
    githubToken,
    label,
    reviewers,
  };
}

async function hasBranchDifferences(owner, repo, sourceBranch, targetBranch) {
  const basehead = `${targetBranch}...${sourceBranch}`;
  const { data: output } = await octokit.rest.repos.compareCommitsWithBasehead({
    owner,
    repo,
    basehead
  });  
  return output.files.length > 0;
}

function setPullRequestOutput(pullRequest) {
  core.setOutput('url', pullRequest.html_url);
  core.setOutput('title', pullRequest.title);
}

async function createNewPullRequest(owner, repo, sourceBranch, targetBranch) {
  const { data: pullRequest } = await octokit.rest.pulls.create({
    owner,
    repo,
    head: sourceBranch,
    base: targetBranch,
    title: `Autogenerated - merge from ${sourceBranch} into ${targetBranch}`
  });
  core.notice('Pull request - created');
  return pullRequest;
}

async function addReviewersToPullRequest(owner, repo, pullNumber, reviewers) {
  if (reviewers !== undefined && reviewers.split(',').length > 0) {  
    await octokit.rest.pulls.requestReviewers({
      owner,
      repo,
      pull_number: pullNumber,
      reviewers: reviewers.split(','),
    });
    core.notice('Pull request - reviewers added');
  }
}

async function run() {
  try {
    const { sourceBranch, targetBranch, githubToken, label, reviewers } = getInputs();
    // eslint-disable-next-line new-cap
    octokit = new github.getOctokit(githubToken);
    const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");    
    const hasDiffs = await hasBranchDifferences(owner, repo, sourceBranch, targetBranch);
    if (hasDiffs === true) {
      const pullRequest = await createNewPullRequest(owner, repo, sourceBranch, targetBranch);
      await addLabel(owner, repo, pullRequest.number, label);
      await addReviewersToPullRequest(owner, repo, pullRequest.number, reviewers);
      setPullRequestOutput(pullRequest);
    }
    else {
      core.notice('Branches have no file differences - no pull request created');
    }
  }
  catch (error) {
    core.setFailed(error.message);
  }
}

run();

module.exports = run;
